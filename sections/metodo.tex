\chapter{Metodologia}
\section{Desempenho Computacional}
Três abordagens distintas serão consideradas nessa parte: A utilização de um 
\textit{cluster}, Python na sua implementação original (CPython) e Cython.
As medições do tempo de execução, realizadas por meio da biblioteca \textit{time},
levarão em conta apenas os trechos do código
que se repetem várias vezes e que, consequentemente, contém os maiores
``gargalos'' na simulação.

\subsection{Cluster Águia}
O \textit{cluster} Águia é composto por 64 servidores físicos com 20 \textit{cores} e 
512 GB de RAM. Seu processador é um Intel(R) Xeon(R) CPU E7-2870 com 2.4 GHz.
A versão do Python disponível para utilização nesse sistema é 2.7.13, da
distribuição Anaconda2 4.4.0.

Primeiramente, o uso de ferramentas para passagem de mensagens em um sistema
distribuído será analisado para simulações simples, com uma corrente injetada
de 10 nA no soma de MNs. O cálculo da força gerada também será computado.
Para esse fim, o pacote
Python MPI4Py, que possibilita o uso do todos os recursos do \textit{cluster},
será utilizado. Serão utilizados 2, 4, 8 e 16 processos em um único servidor.

Para possibilitar que o problema abordado pudesse ser divididos em unidades menores
de computação, foram identificados algumas \textit{tasks} primitivas: os cálculos
da força e das equações diferenciais das unidades motoras. As unidades
motoras são independentes entre si e não precisam receber mensagens durante a
simulação, mas a parte de cálculo de força precisa receber, a cada passo de
tempo, valores relativos de disparos das unidades motoras. Sendo assim,  as
unidades motoras enviam, no final de cada passo da simulação,
seus valores de disparos para as \textit{tasks} de cálculo de força, que
apenas as recebem e realizam suas computações.

As computações das unidades
motoras serão divididas igualmente entre os processos criados, 
enquanto que a \textit{task} de cálculo da força deve ocupar sozinha um único
processo. Os parâmetros que serão usados para analisar a qualidade do programa
paralelo são o \textit{speed up} (ou aceleração), calculado pela equação

\begin{equation}
    S = \frac{t_s}{t_p},
\label{eq:speedup}
\end{equation}

em que $t_s$ e $t_p$ são o tempo de execução serial e paralelo, respectivamente,
e a eficiência, calculada por

\begin{equation}
    E = \frac{t_s}{N t_p},
\end{equation}

sendo $N$ o número de processadores utilizados.

Os valores de $t_s$ e $t_p$ são obtidos a partir da média de 10 simulações com
400 unidades motoras e duração de 0.5 segundos.

\subsection{Python}
Essa estratégia se baseia no uso do conceito de vetorização. O código atual 
utiliza uma matriz de condutâncias de cada compartimento do modelo para
realizar cálculos sobre os potenciais de membrana. O objetivo é criar uma
matriz maior que contenha cada uma dessas matrizes menores, de forma que o 
processo de vetorização possa trazer otimizações. Isso será realizado para 
todos os MNs, INs e algumas outras variáveis envolvidas no cálculo do potencial
de membrana. A implementação antiga das matrizes será identificada como $G_c$ e
a nova proposta, como $G_g$.

Nessa parte será utilizado um sistema operacional Linux
64 bits com oito processadores Intel Core i7-2600 a 3.40 GHz e 7.8 GB de RAM.
A versão do Python utilizada é a 2.7.14, da distribuição Anaconda2 5.0.1-1.
De forma geral, as simulações consistirão de comandos descendentes ativando
MNs.
O tempo de execução será obtido a partir da média de 5 resultados
para diferentes quantidades de MNs
(variação no tamanho da matriz de condutância).

\subsection{Cython}
A biblioteca relativa a esse compilador pode ser carregada de forma simples no
Python. A estrutura do código, entretanto, terá que passar por algumas
modificações. De forma geral, as maiores diferenças entre um código que usa
Cython um com Python puro são algumas chamadas de funções e declaração de
variáveis. Considerando o tamanho e complexidade do código do simulador e o
fato de algumas declarações do Cython serem opcionais, pretende-se iniciar uma
conversão de uma parte desse código, de forma que, ao final desse processo, os
módulos principais usados nas simulações possam ser compilados com
Cython. A métrica usada para medir o ganho de desempenho é a mesma da 
equação (\ref{eq:speedup}), mas usando os tempos de execução das soluções em 
Python e Cython.

\section{Estudo das Parametrizações}
O modelo estudado aqui passará por etapas de comparação com resultados descritos
na literatura. Inicialmente, as parametrizações antiga e nova serão usadas 
nessas avaliações, mas a ideia é que se tenha uma nova parametrização ao final 
desse processo que será usada nos estudos de variabilidade de força
explicitados na seção \ref{sec:for}.

\subsection{Validação do Modelo}
Essa etapa será realizada de forma qualitativa e semiquantitativa.
Em primeiro lugar, serão 
analisadas características de frequência e padrão de disparos de MNs e CRs,
assim como a ordem de recrutamento de MNs sob o efeito das CRs.

As simulações para esse estudo foram
realizadas em um núcleo motor do músculo soleus, com 800 MNs do tipo S, 50 do
tipo FR, 50 do tipo FF e 350 CRs. Essas quantidades foram estimadas a partir de
dados experimentais de humanos \cite{cisi08}. Foi injetada no soma dos MNs uma
corrente em rampa. Esta corrente injetada começa em zero e
aumenta linearmente até o valor final de 20 nA ao final da simulação, que teve
duração de 1000 ms. Os
instantes de disparos dos neurônios envolvidos na simulação serão analisados.
Além disso, espera-se que a inibição recorrente não altere a ordem de 
recrutamento dos MNs, de acordo com o que foi mostrado por \citeonline{clamann74}.

Em segundo lugar, serão analisados características de pós hiperpolarização 
das CRs e 
Como esses são aspectos importantes do circuito de inibição recorrente,
deve ser realizada também após a 

\subsection{Comparações entre Modelos}
O objetivo desta etapa é entender como o simulador aqui estudado se comporta 
em algumas situações propostas por outros trabalhos de simulação. Dessa forma,
serão configuradas simulações que sejam o mais semelhante possível a esses 
trabalhos para que os resultados possam ser apropriadamente comparados.

Os trabalhos em questão, juntamente com os resultados que serão aqui abordados,
são apresentados abaixo. Vale ressaltar que os métodos utilizados para a 
obtenção dos resultados serão os mesmos empregados pelos autores, que foram
analisados com e sem CRs. Os trabalhos alvo são:

\begin{itemize}
	\item \citeonline{maltenfort98}, com espectro de potência da atividade da
		  população de MNs;
	\item \citeonline{uchiyama03b}, com relações de comandos descendentes com
		  taxa de disparos de MNs e CRs e força muscular resultante;
	\item \citeonline{williams09}, com espectro de potência dos disparos de uma
		  população de MNs e da força muscular.
\end{itemize}

\section{Variabilidade da Força}
\label{sec:for}
Para essa análise, dois cenários foram considerados: um que simule o controle
de força exercida pelo calcanhar em um pedal fixo e outro em um pedal livre.
Em ambos os casos, os primeiros 500 ms segundos do sinal da força gerada serão
ignorados. A quantidade de elementos neuronais é a mesma da mostrada
na seção anterior, mas o tempo de simulação foi estendido para 3500 ms.

Uma força a 20\% da contração máxima voluntária será tomada como referência e
o seu coeficiente de variação e sua densidade espectral de potência serão
calculados. Esses resultados serão analisados em simulações com e sem CRs.
Na ausência de inibição recorrente, os comandos descendentes agindo sobre
os MNs serão ajustados de forma a produzir a mesma taxa de disparo da
situação com CR.
